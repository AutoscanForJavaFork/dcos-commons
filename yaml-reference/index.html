<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>YAML Reference</title>
<link rel="stylesheet" type="text/css" media="all" href="/dcos-commons/style/yaml-reference.css" />
<link rel="shortcut icon" type="image/png" href="https://mesosphere.com/favicon.ico"/>
<!-- The Dropdown library is written by Stephen Morley, licensed CC0 1.0 Universal (Public Domain Dedication)-->
<link rel="stylesheet" type="text/css" media="all" href="/dcos-commons/style/Dropdown.css" />
<script src="/dcos-commons/style/Dropdown.js"></script>
<style type="text/css">
/* set the background color of menu items */
.dropdown, .dropdown ul { background: #555555; clear: both; }
/* set the background color of active items */
.dropdown li:hover > a, .dropdown li:hover > span, .dropdown li.dropdownOpen > a, .dropdown li.dropdownOpen > span { background: #af87e0; }
/* pad items, set their text color, and fade their background color */
.dropdown a, .dropdown span { padding: 0.25em 0.5em; color: white; transition: background 0.2s; }
/* show '+' on expandable items */
.dropdown span:after { content: " +"; }

/* toc style: remove extra margin between elements */
.section-nav ul { margin: 0; }
</style>
</head>

<body>
<div id="wrapper">

<a href="/dcos-commons/">
<img style="float: left; margin-bottom: 2em" src="https://mesosphere.com/wp-content/themes/mesosphere/library/images/assets/dcos-sdk-logo.png" width="250" alt="DC/OS Software Development Kit" />
</a>
<img style="float: right" src="https://img.shields.io/badge/Status-Alpha-BF97F0.svg?style=flat-square" alt="Status: Alpha" />



<ul class="dropdown" style="clear: both">
  <li>
    <a href="/dcos-commons/">Home</a>
  </li>
  <li>
    <span>Documentation</span>
    <ul>
      
      
      
      <li><a href="/dcos-commons/developer-guide/">SDK Developer Guide</a></li>
      
      <li><a href="/dcos-commons/plans/">Plans and Deployment</a></li>
      
      <li><a href="/dcos-commons/multi-service/">Building Multi-Service Schedulers</a></li>
      
      <li><a href="/dcos-commons/yaml-reference/">YAML Reference</a></li>
      
      <li><a href="/dcos-commons/faq/">Frequently Asked Questions</a></li>
      
      <li><a href="/dcos-commons/glossary/">Glossary</a></li>
      
      <li><a href="/dcos-commons/reference/api">Javadoc Reference</a></li>
      <li><a href="/dcos-commons/reference/swagger-api">REST APIs</a></li>
    </ul>
  </li>
  <li>
    <span>Tutorials</span>
    <ul>
      
      
      
      <li><a href="/dcos-commons/tutorials/secrets-tutorial/">Secrets Tutorial</a></li>
      
    </ul>
  </li>
  
  <li><a href="https://github.com/mesosphere/dcos-commons/blob/master/CONTRIBUTING.md">Contributing</a></li>
  <li><a href="http://chat.dcos.io" target="_blank">Slack</a></li>
</ul>
<h1>YAML Reference</h1>
<div id="content">

<!--  disable mustache templating in this file: retain templated examples as-is -->

<p>This reference document is a field-by-field listing of the YAML schema used for <a href="../developer-guide/#introduction-to-dcos-service-definitions">Service Specifications</a>. For an example of a real-world YAML Service Spec, see the <a href="https://github.com/mesosphere/dcos-commons/blob/master/frameworks/helloworld/src/main/dist/svc.yml">svc.yml for hello-world</a>. For several smaller examples, see the <a href="../developer-guide/">SDK Developer Guide</a>.</p>

<p>This documentation effectively reflects the Java object tree under <a href="../reference/api/?com/mesosphere/sdk/specification/yaml/RawServiceSpec.html">RawServiceSpec</a>, which is what’s used as the schema to parse YAML Service Specifications. What follows is a field-by-field explanation of everything within that tree. For more information about service development in general, see the <a href="../developer-guide/">SDK Developer Guide</a>.</p>

<h2 id="fields">Fields</h2>

<ul>
  <li>
    <p><code class="highlighter-rouge">name</code></p>

    <p>The name of the service. This is used both for the Marathon app name for the scheduler, as well as for the Mesos framework name for the service tasks.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">web-url</code></p>

    <p>Where requests should be sent when a user goes to <code class="highlighter-rouge">http://theircluster.com/service/&lt;name&gt;</code> to view the service. By default this will go to the scheduler API endpoints. If you wish to expose additional custom endpoints via this URL, you should consider configuring <a href="../developer-guide/#proxy-fallback">Reproxy</a> in your service so that the scheduler API endpoints are still available.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">scheduler</code></p>

    <p>This section contains settings related to the scheduler and its interaction with the cluster. All of these settings are optional, reasonable defaults are used if they are not manually provided.</p>

    <ul>
      <li>
        <p><code class="highlighter-rouge">principal</code></p>

        <p>The Mesos Principal to register as. Default is <code class="highlighter-rouge">&lt;name&gt;-principal</code>.</p>
      </li>
      <li>
        <p><code class="highlighter-rouge">zookeeper</code></p>

        <p>Custom zookeeper URL for storing scheduler state. Defaults to <code class="highlighter-rouge">master.mesos:2181</code>.</p>
      </li>
      <li>
        <p><code class="highlighter-rouge">user</code></p>

        <p>The system user to run the service’s scheduler and pods as, with default <code class="highlighter-rouge">root</code> if unspecified. Availability of usernames depends on the cluster. In DC/OS Enterprise, if the security mode is set to strict, the service account used by the service must have permissions to launch tasks as the assigned user.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><code class="highlighter-rouge">pods</code></p>

    <p>This section contains a listing of all pod types managed by the service.</p>

    <ul>
      <li>
        <p><code class="highlighter-rouge">ipc-mode</code>
IPC (POSIX/SysV IPC) namespace provides separation of named shared memory segments, semaphores and message queues. Shared memory segments are used to accelerate inter-process communication at memory speed, rather than through pipes or through the network stack.</p>

        <p>Specifies the IPC mode to run pod in. Only PRIVATE is valid at the pod level.</p>

        <p>PRIVATE: Private shared memory directory.</p>

        <p>SHARE_PARENT: Share parent is invalid at the pod level.</p>
      </li>
      <li>
        <p><code class="highlighter-rouge">shm-size</code></p>

        <p>Defines the size of the shared memory.</p>
      </li>
      <li>
        <p><code class="highlighter-rouge">resource-sets</code></p>

        <p>Resource sets allow defining a single set of resources to be reused across multiple tasks, where only one task may use the resource set at a time. This can be useful when defining maintenance operations. A single resource set can be created, and then assigned to multiple operations such as backup, restore, rebuild, etc… In this scenario, only one operation may be active at a time, as that task has ownership of the resource set.</p>

        <ul>
          <li>
            <p><code class="highlighter-rouge">cpus</code>, <code class="highlighter-rouge">gpus</code>, <code class="highlighter-rouge">memory</code>, <code class="highlighter-rouge">ports</code>, <code class="highlighter-rouge">volume</code>/<code class="highlighter-rouge">volumes</code>, <code class="highlighter-rouge">resource-limits</code></p>

            <p>These resource values are identical in meaning to their sister fields in a <a href="#tasks">task definition</a>. However, see above discussion about these resources only being used by one task at a time.</p>
          </li>
        </ul>
      </li>
      <li>
        <p><code class="highlighter-rouge">placement</code></p>

        <p>Any additional constraints to be applied when deciding where to deploy this pod. This field supports all <a href="https://mesosphere.github.io/marathon/docs/constraints.html">Marathon placement operators</a>. For example, <code class="highlighter-rouge">[["hostname", "UNIQUE"]]</code> ensures that at most one pod instance is deployed per agent. This value may be exposed to end users via mustache templating to allow customizing placement of the service within their own environment.</p>
      </li>
      <li>
        <p><code class="highlighter-rouge">count</code></p>

        <p>The number of pods of this type to be deployed. This may either be hardcoded or exposed to end users via mustache templating. This value may always be increased after the service has been deployed, but it can only be decreased if <code class="highlighter-rouge">allow-decommission</code> is <code class="highlighter-rouge">true</code>.</p>
      </li>
      <li>
        <p><code class="highlighter-rouge">allow-decommission</code></p>

        <p>Whether to allow this pod’s <code class="highlighter-rouge">count</code> to be decreased by an operator in a configuration update. For safety reasons this defaults to <code class="highlighter-rouge">false</code>, but the service developer may set this field to <code class="highlighter-rouge">true</code> to explicitly allow scale-down on a per-pod basis.</p>
      </li>
      <li>
        <p><code class="highlighter-rouge">image</code></p>

        <p>The docker image to use for launching the pod, of the form <code class="highlighter-rouge">user/img:version</code>. The image may either be in public Docker Hub, or in a custom Docker Registry. Any custom Docker Registry must have been <a href="https://github.com/dcos/examples/tree/master/1.8/registry">configured in the DC/OS cluster</a> to work. To ensure a lack of flakiness, docker images are only executed by Mesos’ <a href="https://docs.mesosphere.com/1.9/deploying-services/containerizers/">Universal Container Runtime</a>, never <code class="highlighter-rouge">dockerd</code>. If this is unspecified, then a sandboxed directory on the system root is used instead.</p>

        <p>You do not have to specify an image if the service uses static binaries or an environment like the JVM to handle any runtime dependencies, but if your application requires a custom environment and/or filesystem isolation then you should probably specify an image here.</p>
      </li>
      <li>
        <p><code class="highlighter-rouge">rlimits</code></p>

        <p>This section may be used to specify <a href="https://linux.die.net/man/2/setrlimit">rlimits</a> that need to be configured (by Mesos) before the container is brought up. One or more rlimit values may be specified as follows:</p>

        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rlimits:
  RLIMIT_AS: // unlimited when 'soft' and 'hard' are both unset
  RLIMIT_NOFILE:
    soft: 128000
    hard: 128000
</code></pre></div>        </div>
      </li>
      <li>
        <p><code class="highlighter-rouge">secrets</code></p>

        <p>This section list the Secrets that will be made available to the pod. The content of a Secret may be exposed as a file and/or as a environment variable.
If Secret content is changed, relevant pod needs to be restarted, so it can update new content from the Secret store.</p>

        <ul>
          <li>
            <p><code class="highlighter-rouge">secret</code></p>

            <p>The path of a Secret. This setting would typically be configurable by service users as it must match what path the administrator used in the DC/OS Secrets UI.</p>
          </li>
          <li>
            <p><code class="highlighter-rouge">env-key</code></p>

            <p>Name of the environment variable to expose the Secret content against. This may be left unset if the secret shouldn’t be provided as an environment variable.</p>
          </li>
          <li>
            <p><code class="highlighter-rouge">file</code></p>

            <p>A path within the container to copy the Secret content into. The Secret file is a tmpfs file; it disappears when executor exits.</p>
          </li>
        </ul>
      </li>
      <li>
        <p><code class="highlighter-rouge">networks</code></p>

        <p>Allows the pod to join any number of virtual networks on the DC/OS cluster. One kind of virtual network that is supported at present is the <code class="highlighter-rouge">dcos</code> overlay network. To have the pod join a virtual network (the <code class="highlighter-rouge">dcos</code> overlay network in this case) add the following to its YAML specification:</p>

        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>networks:
  dcos:
</code></pre></div>        </div>

        <p>Pods on virtual networks have the following effects:</p>

        <div class="noyaml"><ul>
<li>The pod receives its own IP address from the subnet of the virtual network belonging to the agent where the pod is deployed. The IP can be retrieved using the DNS <code>&lt;task_name&gt;.&lt;framework_name&gt;.autoip.dcos.thisdcos.directory</code>. This DNS will also work for pods on the native host network.</li>
<li>The <code>ports</code> resource requirements will be ignored (i.e. the agent does not need to have these ports available) because the pod has its own IP address.</li>
<li>Once the pod is on a virtual network, you cannot move it to the host network. This is disallowed because the ports may not be available on the agent that has the rest of the task's reserved resources.</li>
</ul></div>

        <p>For more information see the <a href="https://docs.mesosphere.com/1.9/networking/virtual-networks/#virtual-network-service-dns">DC/OS Virtual Network documentation</a>.</p>
      </li>
      <li>
        <p><code class="highlighter-rouge">uris</code></p>

        <p>A list of uris to be downloaded (and automatically unpacked) into the <code class="highlighter-rouge">$MESOS_SANDBOX</code> directory before launching instances of this pod. It is strongly recommended that all URIs be templated out and provided as scheduler environment variables. This allows field replacement in the case of running an offline cluster without internet connectivity.</p>

        <p>If you’re using a Docker image (specified in the <code class="highlighter-rouge">image</code> field), these bits should ideally be already pre-included in that image, but separate downloads can regardless be useful in some situations.</p>

        <p>If you wish to use <code class="highlighter-rouge">configs</code> in your tasks, this needs to include a URI to download the <code class="highlighter-rouge">bootstrap</code> executable.</p>
      </li>
      <li>
        <p><code class="highlighter-rouge">volume</code>/<code class="highlighter-rouge">volumes</code></p>

        <p>One or more persistent volumes to be mounted into the pod environment. These behave the same as volumes on a task or resource set, but are guaranteed to be shared between tasks in a pod. Although volumes defined on a task currently behave the same way, individual tasks will not be able to access volumes defined by another task in the future.</p>
      </li>
      <li>
        <p><code class="highlighter-rouge">pre-reserved-role</code></p>

        <p>Ensures that this pod only consumes resources against a role which has already been statically assigned within the cluster. This is mainly useful for placing pods within a predefined quota, or otherwise assigning them a specific set of resources. For example, DC/OS clusters have a convention of using the <code class="highlighter-rouge">slave_public</code> role for machines which are not firewalled. Pods which have their <code class="highlighter-rouge">pre-reserved-role</code> set to <code class="highlighter-rouge">slave_public</code> will be placed on those machines so that they are visible outside the cluster.</p>
      </li>
      <li>
        <p><code class="highlighter-rouge">share-pid-namespace</code></p>

        <p>Whether the tasks within this pod should share the same process id namespace (<code class="highlighter-rouge">true</code>), or whether pid namespaces should be distinct for every task in the pod (<code class="highlighter-rouge">false</code>). Default is <code class="highlighter-rouge">false</code>.</p>
      </li>
      <li>
        <p><code class="highlighter-rouge">tasks</code></p>

        <p>This section lists the tasks which run within a given pod. All tasks share the same pod environment and resources. Resources may be more granularly allocated on a per-task basis in the future.</p>

        <ul>
          <li>
            <p><code class="highlighter-rouge">goal</code></p>

            <p>The goal state of the task. Must be either <code class="highlighter-rouge">RUNNING</code>, <code class="highlighter-rouge">FINISH</code> or <code class="highlighter-rouge">ONCE</code>:</p>

            <ul>
              <li>
                <p><code class="highlighter-rouge">RUNNING</code></p>

                <p>The task should launch and continue running indefinitely. If the task exits, the entire pod (including any other active tasks) is restarted automatically. To demonstrate, let’s assume a running instance the <code class="highlighter-rouge">hello-world</code> service on your DC/OS cluster. We’ll be updating the configuration of the <code class="highlighter-rouge">hello-0</code> pod and verifying that the <code class="highlighter-rouge">hello-0-server</code> task with goal state <code class="highlighter-rouge">RUNNING</code> is restarted and stays running. First, we verify that the deploy plan has completed:</p>
                <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ dcos hello-world plan show deploy
deploy (COMPLETE)
├─ hello (COMPLETE)
│  └─ hello-0:[server] (COMPLETE)
...
</code></pre></div>                </div>
                <p>Now we take note of the ID of the <code class="highlighter-rouge">hello-0-server</code> task:</p>
                <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ dcos task
NAME            HOST         USER   STATE  ID                                                    MESOS ID                                   REGION      ZONE
hello-0-server  10.0.3.117  nobody    R    hello-0-server__46cf0925-9287-486b-83d7-7ffc43523671  61eee73c-b6a5-473c-990d-4bc8051cbd82-S4  us-west-2  us-west-2c
...
</code></pre></div>                </div>
                <p>Next, we update the amount of CPU being used by the <code class="highlighter-rouge">server</code> task in the <code class="highlighter-rouge">hello</code> pod type:</p>
                <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ echo '{"hello": {"cpus": 0.2}}' &gt; options.json
$ dcos hello-world update start --options=options.json
</code></pre></div>                </div>
                <p>After waiting for the update to complete and all tasks to be relaunched, we check the list of running tasks once again to verify that the <code class="highlighter-rouge">hello-0-server</code> step is complete, that the task was restarted (which we’ll determine by verifying that it has a different task ID) and that it’s still running:</p>
                <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ dcos hello-world plan show deploy
deploy (COMPLETE)
├─ hello (COMPLETE)
│  └─ hello-0:[server] (COMPLETE)
...
$ dcos task
NAME            HOST         USER   STATE  ID                                                    MESOS ID                                   REGION      ZONE
hello-0-server  10.0.3.117  nobody    R    hello-0-server__3007283c-837d-48e1-aa0b-d60baead6f4e  61eee73c-b6a5-473c-990d-4bc8051cbd82-S4  us-west-2  us-west-2c
</code></pre></div>                </div>
              </li>
              <li>
                <p><code class="highlighter-rouge">FINISH</code></p>

                <p>The task should launch and exit successfully (zero exit code). If the task fails (nonzero exit code) then it is retried without relaunching the entire pod. If that task’s configuration is updated, it is rerun. To demonstrate, let’s assume that we’ve now launched hello-world with the <code class="highlighter-rouge">finish_state.yml</code> specfile, like so:</p>
                <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ echo '{"service": {"yaml": "finish_state"}}' &gt; options.json
$ dcos package install --yes hello-world --options=options.json
</code></pre></div>                </div>
                <p>Once again, we wait for the deploy plan to complete, as above, and take note of the ID of the <code class="highlighter-rouge">world-0-finish</code> task (this time using the <code class="highlighter-rouge">--completed</code> flag, since the task has run to completion):</p>
                <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ dcos task --completed
NAME            HOST         USER   STATE  ID                                                    MESOS ID                                   REGION      ZONE
...
world-0-finish  10.0.0.232  nobody    F    world-0-server__955a28c2-d5bc-4ce4-a4e9-b9603784382e  61eee73c-b6a5-473c-990d-4bc8051cbd82-S3  us-west-2  us-west-2c
...
</code></pre></div>                </div>
                <p>Now we update the amount of CPU being used by the <code class="highlighter-rouge">finish</code> task in the <code class="highlighter-rouge">world</code> pod type:</p>
                <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ echo '{"world": {"cpus": 0.2}}' &gt; options.json
$ dcos hello-world update start --options=options.json
</code></pre></div>                </div>
                <p>After waiting for the update to complete, we check the task list again and this time see two completed entries for <code class="highlighter-rouge">world-0-finish</code>, showing that the configuration update has caused it to run to completion again:</p>
                <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ dcos task --completed
NAME            HOST         USER   STATE  ID                                                    MESOS ID                                   REGION      ZONE
...
world-0-finish  10.0.0.232  nobody    F    world-0-finish__955a28c2-d5bc-4ce4-a4e9-b9603784382e  61eee73c-b6a5-473c-990d-4bc8051cbd82-S3  us-west-2  us-west-2c
world-0-finish  10.0.3.117  nobody    F    world-0-finish__bd03efc2-26a0-4e36-a332-38159492557e  61eee73c-b6a5-473c-990d-4bc8051cbd82-S4  us-west-2  us-west-2c
...
</code></pre></div>                </div>
              </li>
              <li>
                <p><code class="highlighter-rouge">ONCE</code></p>

                <p>The task should launch and exit successfully (zero exit code). If the task fails (nonzero exit code) then it is retried without relaunching the entire pod. If that task’s configuration is updated, it will not be rerun. To demonstrate, let’s assume that this time we’ve launched hello-world with the <code class="highlighter-rouge">discovery.yml</code> specfile, like so:</p>
                <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ echo '{"service": {"yaml": "discovery"}}' &gt; options.json
$ dcos package install --yes hello-world --options=options.json
</code></pre></div>                </div>
                <p>Again we wait for the deploy plan to complete and take note of the ID of the <code class="highlighter-rouge">hello-0-once</code> task, using the <code class="highlighter-rouge">--completed</code> flag since that task has run to completion:</p>
                <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ dcos task --completed
NAME            HOST         USER   STATE  ID                                                    MESOS ID                                   REGION      ZONE
...
hello-0-once  10.0.3.117  nobody    F    hello-0-once__8f167b23-48c8-4ea9-8559-4cf95a3703ae  61eee73c-b6a5-473c-990d-4bc8051cbd82-S4  us-west-2  us-west-2c
...
</code></pre></div>                </div>
                <p>Now we update the amount of CPU being used by both tasks in the <code class="highlighter-rouge">hello</code> pod type:</p>
                <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ echo '{"hello": {"cpus": 0.2}}' &gt; options.json
$ dcos hello-world update start --options=options.json
</code></pre></div>                </div>
                <p>After waiting for deployment to complete, we check the task list and find that <code class="highlighter-rouge">hello-0-once</code> only appears one time, indicating that the configuration update did not cause it to rerun:</p>
                <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ dcos task --completed
NAME            HOST         USER   STATE  ID                                                    MESOS ID                                   REGION      ZONE
...
hello-0-once  10.0.3.117  nobody    F    hello-0-once__8f167b23-48c8-4ea9-8559-4cf95a3703ae  61eee73c-b6a5-473c-990d-4bc8051cbd82-S4  us-west-2  us-west-2c
...
</code></pre></div>                </div>
              </li>
            </ul>
          </li>
          <li>
            <p><code class="highlighter-rouge">essential</code></p>

            <p>Marks this task as either “Essential”, where task failure results in relaunching all tasks in the pod as a unit, or “Non-essential”, where task failure results in only relaunching this task and leaving other tasks in the pod unaffected. By default this value is <code class="highlighter-rouge">true</code>, such that the failure of the task will result in relaunching all tasks in the pod. This is only applicable in cases where a given pod has multiple tasks with a goal state of <code class="highlighter-rouge">RUNNING</code> defined.</p>
          </li>
          <li>
            <p><code class="highlighter-rouge">cmd</code></p>

            <p>The command to be run by the task, in the form of a shell script. This script may execute any executables that are visible within the pod environment.</p>

            <p>If you wish to use <code class="highlighter-rouge">configs</code> in this task, the <code class="highlighter-rouge">cmd</code> needs to run the <code class="highlighter-rouge">bootstrap</code> executable. For example: <code class="highlighter-rouge">./bootstrap &amp;&amp; ./your/exe/here</code></p>
          </li>
          <li>
            <p><code class="highlighter-rouge">env</code></p>

            <p>A listing of environment variables to be included in the <code class="highlighter-rouge">cmd</code> runtime. If you’re using config templates using <code class="highlighter-rouge">bootstrap</code>, this section must be populated with any relevant template values.</p>

            <p>For convenience, the following environment variables are automatically provided to all tasks:</p>
            <div class="noyaml"><ul>
<li><code>TASK_NAME</code>: The name of the task, of the form <code>&lt;pod&gt;-&lt;#&gt;-&lt;task&gt;</code>. For example: <code>mypod-0-node</code>.</li>
<li><code>FRAMEWORK_NAME</code>: The name of the service.</li>
<li><code>FRAMEWORK_HOST</code>: The host domain for pods on the service. For example, the full hostname for a task would be <code>[TASK_NAME].[FRAMEWORK_HOST]</code>.</li>
<li><code>FRAMEWORK_VIP_HOST</code>: The host domain for VIPs on the service. For example, the full hostname for a VIP would be <code>[VIP_NAME].[FRAMEWORK_VIP_HOST]</code>.</li>
<li><code>SCHEDULER_API_HOSTNAME</code>: The hostname for the Scheduler HTTP API. For example, an endpoint on the scheduler would be <code>http://[SCHEDULER_API_HOSTNAME]/myendpoint</code>.</li>
<li><code>POD_INSTANCE_INDEX</code>: The index of the pod instance, starting at 0 for the first instance.</li>
<li><code>&lt;TASK_NAME&gt;=true</code>: The task name as the envvar name, with <code>true</code> as the value.</li>
</ul></div>
          </li>
          <li>
            <p><code class="highlighter-rouge">configs</code></p>

            <p>This section allows specifying config templates to be rendered by the <code class="highlighter-rouge">bootstrap</code> executable, which must be invoked manually in <code class="highlighter-rouge">cmd</code>. A common use case for DC/OS services is allowing end-users to customize the configuration of the service. This allows specifying arbitrary text templates which are automatically populated with that configuration. For example, say we had a <code class="highlighter-rouge">webserver</code> task with a <code class="highlighter-rouge">config.yaml</code> like the following:</p>

            <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hostname: localhost
port: 80
ssl:
  enabled: true
  key: /etc/ssl/priv.key
  cert: /etc/ssl/pub.cert
# Default value when unset:
#custom_404: 404 Not Found
#custom_403: 403 Forbidden
root: /var/www
</code></pre></div>            </div>

            <p>The service developer can create a <code class="highlighter-rouge">config.yaml.mustache</code> which templates out the options to be exposed to end users:</p>

            <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hostname: {{TASK_NAME}}.{{FRAMEWORK_NAME}}.mesos // mesos-dns hostname for this task
port: {{PORT_HTTP}}
ssl:
  enabled: {{SSL_ENABLED}}
  key: /etc/ssl/priv.key // not customizable
  cert: /etc/ssl/pub.cert // not customizable
{{#CUSTOM_404_MESSAGE}}
custom_404: {{CUSTOM_404_MESSAGE}}
{{/CUSTOM_404_MESSAGE}}
{{#CUSTOM_403_MESSAGE}}
custom_403: {{CUSTOM_403_MESSAGE}}
{{/CUSTOM_403_MESSAGE}}
root: {{ROOT_DIR}}
</code></pre></div>            </div>

            <p>And then the following settings would be manually added to the task’s <code class="highlighter-rouge">env</code>. These env vars meanwhile would be provided automatically by the SDK:</p>
            <div class="noyaml"><ul>
<li><code>TASK_NAME</code> and <code>FRAMEWORK_NAME</code> are included for free, as mentioned under <code>env</code> above.</li>
<li><code>PORT_HTTP</code> is the default advertised environment variable for a reserved port named <code>http</code>, as mentioned under <code>ports</code> below.</li>
</ul></div>

            <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>env:
  SSL_ENABLED: {{WEB_SSL_ENABLED}}
  CUSTOM_404_MESSAGE: {{WEB_CUSTOM_404_MESSAGE}}
  CUSTOM_403_MESSAGE: {{WEB_CUSTOM_403_MESSAGE}}
  HTTP_ROOT: {{WEB_ROOT_DIR}}
</code></pre></div>            </div>

            <p>See the <a href="../developer-guide/">SDK Developer Guide</a> more information on each of these files.</p>

            <ul>
              <li>
                <p><code class="highlighter-rouge">template</code></p>

                <p>The source template file path within the <em>scheduler</em> environment to be downloaded into the task. Relative paths are interpreted as relative to the <em>scheduler’s</em> <code class="highlighter-rouge">$MESOS_SANDBOX</code>.</p>
              </li>
              <li>
                <p><code class="highlighter-rouge">dest</code></p>

                <p>The destination path within the <em>task</em> environment to place the rendered result. An absolute or relative path may be used. Relative paths are interpreted as relative to the <em>task’s</em> <code class="highlighter-rouge">$MESOS_SANDBOX</code>.</p>
              </li>
            </ul>
          </li>
          <li>
            <p><code class="highlighter-rouge">cpus</code></p>

            <p>The number of CPUs to be reserved by this task. Fractional values (e.g. <code class="highlighter-rouge">1.5</code>) are supported. If the task exceeds the reserved usage, it will be throttled and inconsistent performance may result.</p>
          </li>
          <li>
            <p><code class="highlighter-rouge">gpus</code></p>

            <p>The number of GPUs to be reserved by this task. Unlike with CPUs this cannot be a fractional value in practice. This is only supported in DC/OS 1.9+.</p>
          </li>
          <li>
            <p><code class="highlighter-rouge">memory</code></p>

            <p>The amount of RAM (in MB) to be reserved by this task. If the task exceeds this amount, it will be forcibly restarted.</p>
          </li>
          <li>
            <p><code class="highlighter-rouge">resource-limits</code></p>

            <p>Allows a pod to consume more CPU or Memory resources than requested.</p>

            <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>resource-limits:
  cpus: unlimited
  mem: 4096
</code></pre></div>            </div>

            <ul>
              <li>
                <p><code class="highlighter-rouge">cpus</code></p>

                <p>(optional) The CPU limit to set, either a number greater than or equal to the requested CPUs, or <code class="highlighter-rouge">unlimited</code>. When set, the task will continue to receive the requested CPUs at the same priority, and any unused CPU cycles up to the limit.</p>
              </li>
              <li>
                <p><code class="highlighter-rouge">mem</code></p>

                <p>(optional) The memory limit to set, either a number greater than or equal to the requested memory, or <code class="highlighter-rouge">unlimited</code>. Tasks that consume more memory than requested and cause the host to run out of memory are at risk of being OOM killed.</p>
              </li>
            </ul>
          </li>
          <li>
            <p><code class="highlighter-rouge">ports</code></p>

            <p>The ports which your service will be using to accept incoming connections. Each port is given a unique name across the service, and this name is what’s used to advertise that port in the <code class="highlighter-rouge">endpoints</code> listing. Ports may be defined a task as follows:</p>

            <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ports:
  http-api:
    port: 0 # use a random port
    advertise: true # advertise the port in service endpoint lookups
    vip:
      port: 80 # create a VIP
  debug:
    port: 9090
    env-key: DEBUG_PORT # advertise DEBUG_PORT=9090 in task env
</code></pre></div>            </div>

            <p>All ports are reserved against the same interface that Mesos uses to connect to the rest of the cluster. In practice you should only use this interface as well. Surprising behavior may result if you use a different interface than Mesos does. For example, imagine dealing with a situation where Mesos loses connectivity on <code class="highlighter-rouge">eth0</code>, but your service is still connected fine over <code class="highlighter-rouge">eth1</code>. Or vice versa.</p>

            <p>It’s worth noting that port reservations in DC/OS are technically honor-system at the moment. However, you should still reserve all the ports you intend to use. This is to ensure that Mesos doesn’t place your task on a machine where a port you need is already occupied. You must give Mesos enough information to find a place where all your required ports are available.</p>
          </li>
        </ul>
      </li>
      <li>
        <p><code class="highlighter-rouge">ipc-mode</code>
IPC (POSIX/SysV IPC) namespace provides separation of named shared memory segments, semaphores and message queues. Shared memory segments are used to accelerate inter-process communication at memory speed, rather than through pipes or through the network stack.</p>

        <p>Specifies the ipc mode to run pod in. PRIVATE and SHARE_PARENT are valid values.</p>

        <p>PRIVATE: Private shared memory directory.</p>

        <p>SHARE_PARENT: Shared memory directory is shared with parent executor.</p>
      </li>
      <li>
        <p><code class="highlighter-rouge">shm-size</code></p>

        <p>Defines the size of the shared memory.</p>

        <ul>
          <li>
            <p><code class="highlighter-rouge">port</code></p>

            <p>The port to be reserved and used by the service. This may be set to <code class="highlighter-rouge">0</code> to use a random port, which will be advertised via the task environment.</p>
          </li>
          <li>
            <p><code class="highlighter-rouge">env-key</code></p>

            <p>This may be used to define an environment variable used to advertise this port within the task. This is most useful when a random dynamic port is being used, as it allows the task to know what port was allocated for it.</p>
          </li>
          <li>
            <p><code class="highlighter-rouge">ranges</code></p>

            <p>When requesting a dynamic port, a list of ranges may be passed to to constrain the value of the dynamic port. The range is inclusive of <code class="highlighter-rouge">begin</code> and <code class="highlighter-rouge">end</code> when they are set. If <code class="highlighter-rouge">begin</code> or <code class="highlighter-rouge">end</code> is not set the range constraint is implicit and unbounded on that side. Ranges may be defined as follows:</p>

            <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ports:
  name1:
    port: 0
    env-key: key1
    ranges:
      - begin: 1
        end: 21
      - begin: 2000
        end: 5050
  name2:
    port: 0
    ranges:
      - begin:
        end: 21
      - begin: 5000
        end:
</code></pre></div>            </div>
          </li>
          <li>
            <p><code class="highlighter-rouge">advertise</code></p>

            <p>This may be manually set to <code class="highlighter-rouge">true</code> to enable advertising this port in the service’s <code class="highlighter-rouge">endpoints</code> listing. Default is <code class="highlighter-rouge">false</code>.</p>
          </li>
          <li>
            <p><code class="highlighter-rouge">vip</code></p>

            <p>This section enables a Virtual IP (or VIP) address for this port. The VIP is effectively a highly-available hostname at which the task may be reached at an arbitrary advertised endpoint. Using VIPs is similar to using Mesos-DNS, except you have more control over the port used by others to connect to your service, without requiring users check SRV records like Mesos-DNS does. For example, you could run several web servers behind random ports (see above), but expose them all a single VIP endpoint at port <code class="highlighter-rouge">80</code>.</p>

            <ul>
              <li>
                <p><code class="highlighter-rouge">port</code></p>

                <p>The ‘external’ port to use in the VIP.</p>
              </li>
              <li>
                <p><code class="highlighter-rouge">prefix</code></p>

                <p>The name to put at the start of the VIP. For example, <code class="highlighter-rouge">http</code> will result in a VIP hostname of <code class="highlighter-rouge">http.&lt;servicename&gt;.l4lb.thisdcos.directory</code>. By default, the parent port’s name is used.</p>
              </li>
            </ul>
          </li>
          <li>
            <p><code class="highlighter-rouge">health-check</code></p>

            <p>Health checks are additional validation that your task is healthy, in addition to just the fact that its process is still running. This is an extra convenience for situations where a service can enter a zombie state from which it can never return. For example, it might query an HTTP endpoint to validate that an HTTP service is still responding.</p>

            <ul>
              <li>
                <p><code class="highlighter-rouge">cmd</code></p>

                <p>This is the command to run in the health check. It will be run in the same environment as the task itself, but any envvars which are assigned <em>within</em> the task’s <code class="highlighter-rouge">cmd</code> will not appear here. If the command exits with code <code class="highlighter-rouge">0</code>, then the health check is considered successful. Otherwise it failed.</p>
              </li>
              <li>
                <p><code class="highlighter-rouge">interval</code></p>

                <p>The period in seconds to wait after the last check has completed to start the next check.</p>
              </li>
              <li>
                <p><code class="highlighter-rouge">grace-period</code></p>

                <p>An initial amount of time in seconds to ignore failed health checks.</p>
              </li>
              <li>
                <p><code class="highlighter-rouge">max-consecutive-failures</code></p>

                <p>The number of consecutive health check failures which are allowed before the task is restarted. An unset value is treated as equivalent to no retries.</p>
              </li>
              <li>
                <p><code class="highlighter-rouge">delay</code></p>

                <p>An amount of time in seconds to wait before starting the readiness check attempts. This delay is triggered once the task has started running.</p>
              </li>
              <li>
                <p><code class="highlighter-rouge">timeout</code></p>

                <p>An amount of time in seconds to wait for a health check to succeed. If all health checks continuously fail for the timeout duration, the task is restarted (and its persistent volumes will persist).</p>
              </li>
            </ul>
          </li>
          <li>
            <p><code class="highlighter-rouge">readiness-check</code></p>

            <p>Readiness checks are similar in implementation to health checks, but they are only run when the task is first coming up. Readiness checks allow the service to expose when a given task has completed some initialization process, as opposed to just exposing that the process is running. If a readiness check is defined, the scheduler will wait until this check passes before attempting to launch another task. Unlike with health checks which are only really needed in specific cases, readiness checks are frequently useful for ensuring that process health during startup accurately represents the internals of the service, and to give the scheduler an opportunity to automatically restart a task if initialization is taking too long.</p>

            <ul>
              <li>
                <p><code class="highlighter-rouge">cmd</code></p>

                <p>This is the command to run in the readiness check. It will be run in the same environment as the task itself, but any envvars which are assigned <em>within</em> the task’s <code class="highlighter-rouge">cmd</code> will not appear here. If the command exits with code <code class="highlighter-rouge">0</code>, then the health check is considered successful. Otherwise it failed.</p>
              </li>
              <li>
                <p><code class="highlighter-rouge">interval</code></p>

                <p>The period in seconds to wait after the last check has completed to start the next check.</p>
              </li>
              <li>
                <p><code class="highlighter-rouge">delay</code></p>

                <p>An amount of time in seconds to wait before starting the readiness check attempts.</p>
              </li>
              <li>
                <p><code class="highlighter-rouge">timeout</code></p>

                <p>An amount of time in seconds to wait for a readiness check to succeed. If all readiness checks continuously fail for the timeout duration, the task is restarted and initialization is reattempted.</p>
              </li>
            </ul>
          </li>
          <li>
            <p><code class="highlighter-rouge">volume</code>/<code class="highlighter-rouge">volumes</code></p>

            <p>One or more persistent volumes to be mounted into the task environment. Any files placed within persistent volumes will survive a task being restarted, but will <em>not</em> survive a task being moved to a new machine. <code class="highlighter-rouge">volume</code> is a convenience syntax for specifying a task with a single volume.</p>

            <ul>
              <li>
                <p><code class="highlighter-rouge">path</code></p>

                <p>Where the persistent volume should be mounted in the task filesystem. A relative path will be placed relative to <code class="highlighter-rouge">$MESOS_SANDBOX</code>.</p>
              </li>
              <li>
                <p><code class="highlighter-rouge">type</code></p>

                <p>Two types are currently supported: <code class="highlighter-rouge">ROOT</code> and <code class="highlighter-rouge">MOUNT</code>. Both behave the same in terms of persistence; the difference is mainly in how they perform and how they’re reserved:</p>
                <div class="noyaml"><ul>
<li><code>ROOT</code> volumes are against the root filesystem of the host system. In terms of performance they will share IO with the other users of that filesystem. In terms of reservations, the requested size is exactly what's obtained.</li>
<li><code>MOUNT</code> volumes are separate partitions which the cluster administrator had mounted onto the host machine as <code>/dcos/volumeN</code>. These partitions will typically have their own dedicated IO/spindles, resulting in more consistent performance. <code>MOUNT</code> volumes are reserved as a unit and are not shared across services. If a service requests a 1 GB volume and the <code>MOUNT</code> volumes are all 100 GB, then the service is getting a 100 GB volume all to itself.</li>
</ul></div>
              </li>
              <li>
                <p><code class="highlighter-rouge">profiles</code></p>

                <p>A list of <a href="https://docs.mesosphere.com/services/beta-storage/0.4.0-beta/terminology-and-concepts/#volume-profile">volume profiles</a> any of which the persistent volume should be provisioned on. This is only supported for <code class="highlighter-rouge">MOUNT</code> volumes in DC/OS 1.12+.</p>
              </li>
              <li>
                <p><code class="highlighter-rouge">size</code></p>

                <p>The required minimum size of the volume. See reservation semantics between <code class="highlighter-rouge">ROOT</code> and <code class="highlighter-rouge">MOUNT</code> volume types above.</p>
              </li>
            </ul>
          </li>
          <li>
            <p><code class="highlighter-rouge">resource-set</code></p>

            <p>Tasks may either be assigned independent resources via the <code class="highlighter-rouge">cpus</code>, <code class="highlighter-rouge">gpus</code>, <code class="highlighter-rouge">memory</code>, <code class="highlighter-rouge">ports</code>, and <code class="highlighter-rouge">volume</code>/<code class="highlighter-rouge">volumes</code> fields, or they may be assigned to a common <code class="highlighter-rouge">resource-set</code> which was defined separately in <code class="highlighter-rouge">resource-sets</code> (see above). Not both.</p>
          </li>
          <li>
            <p><code class="highlighter-rouge">discovery</code></p>

            <p>This may be used to define custom discovery information for the task, affecting how it’s advertised in Mesos DNS.</p>

            <ul>
              <li>
                <p><code class="highlighter-rouge">prefix</code></p>

                <p>A custom name to use for advertising the pod via Mesos DNS. By default this is the pod name, so e.g. a pod specification named <code class="highlighter-rouge">foo</code> will by default have pod with discovery names of <code class="highlighter-rouge">foo-0</code>, <code class="highlighter-rouge">foo-1</code>, and so on.
This value may be used to have pods whose hostnames are Mesos DNS (default <code class="highlighter-rouge">&lt;podname&gt;-&lt;#&gt;-&lt;taskname&gt;.&lt;servicename&gt;.mesos</code>) is different from their task name.
Note that to avoid name collisions, different pods are not allowed to share the same prefix value.</p>
              </li>
              <li>
                <p><code class="highlighter-rouge">visibility</code></p>

                <p>The default visibility for the discovery information. May be <code class="highlighter-rouge">FRAMEWORK</code>, <code class="highlighter-rouge">CLUSTER</code>, or <code class="highlighter-rouge">EXTERNAL</code>. If unset this defaults to <code class="highlighter-rouge">CLUSTER</code>. See <a href="https://mesos.apache.org/documentation/latest/app-framework-development-guide/">Mesos documentation</a> on service discovery for more information on these visibility values.</p>
              </li>
            </ul>
          </li>
          <li>
            <p><code class="highlighter-rouge">labels</code></p>

            <p>This may be used to define custom task labels which will be present in the Mesos state.</p>
          </li>
          <li>
            <p><code class="highlighter-rouge">transport-encryption</code></p>

            <p>A task may optionally ask for a X.509 TLS certificate with private key and CA certificate bundle. A certificate can be used by service to enable secure communication.</p>

            <ul>
              <li>
                <p><code class="highlighter-rouge">name</code></p>

                <p>A name of files representing the TLS artifacts in the task sandbox directory. For example a <code class="highlighter-rouge">name: nginx</code> with <code class="highlighter-rouge">type: TLS</code> will result in <code class="highlighter-rouge">$MESOS_SANDBOX/nginx.crt</code>, <code class="highlighter-rouge">$MESOS_SANDBOX/nginx.key</code> and <code class="highlighter-rouge">$MESOS_SANDBOX/nginx.ca</code> files.</p>
              </li>
              <li>
                <p><code class="highlighter-rouge">type</code></p>

                <p>A type or format of delivered TLS artifacts.
This can be set either to <code class="highlighter-rouge">TLS</code> for PEM encoded private key file, certificate and CA bundle or <code class="highlighter-rouge">KEYSTORE</code> for certificate and private key to be delivered in a separate keystore file and CA bundle in other truststore file.</p>
              </li>
            </ul>

            <p>For detailed information see the <a href="../developer-guide/#tls">SDK Developer Guide</a>.</p>
          </li>
          <li>
            <p><code class="highlighter-rouge">kill-grace-period</code></p>

            <p>When the scheduler is instructed to kill a task, it first sends a <code class="highlighter-rouge">SIGTERM</code> signal to that task so that it can optionally perform any necessary cleanup before it terminates, and then sends a <code class="highlighter-rouge">SIGKILL</code> signal afterward. This field specifies the duration in seconds between when the scheduler sends <code class="highlighter-rouge">SIGTERM</code> and <code class="highlighter-rouge">SIGKILL</code>.</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><code class="highlighter-rouge">plans</code></p>

    <p>This section allows specifying custom deployment behavior, either by replacing the default <code class="highlighter-rouge">deploy</code> plan, replacing the default <code class="highlighter-rouge">update</code> plan (otherwise <code class="highlighter-rouge">deploy</code> is used for updates), and/or by adding new custom plans. This can be useful for overriding the default behavior, which is sequentially deploying all the tasks in the order that they were declared above. Plans are listed in this section by name, with the content of each Plan listing the Phases and Steps to be run within them. See the <a href="../developer-guide/#plans">SDK Developer Guide</a> for some examples and additional information on customizing Plans.</p>

    <ul>
      <li>
        <p><code class="highlighter-rouge">strategy</code></p>

        <p>How the phases within a given plan should be deployed, either <code class="highlighter-rouge">serial</code> or <code class="highlighter-rouge">parallel</code>. For example, a <code class="highlighter-rouge">serial</code> strategy will ensure Phase 1 is only stared after Phase 0 is complete, while a <code class="highlighter-rouge">parallel</code> strategy will start both Phase 0 and Phase 1 at the same time.</p>
      </li>
      <li>
        <p><code class="highlighter-rouge">phases</code></p>

        <p>The list of Phases which compose a given Plan. In the canonical case of a deployment of separate <code class="highlighter-rouge">index</code> and <code class="highlighter-rouge">data</code> nodes, a Phase would represent deploying all of one of those types of nodes.</p>

        <ul>
          <li>
            <p><code class="highlighter-rouge">strategy</code></p>

            <p>How the steps within a given plan should be deployed. This may be any of <code class="highlighter-rouge">serial</code>, <code class="highlighter-rouge">parallel</code>, <code class="highlighter-rouge">serial-canary</code>, or <code class="highlighter-rouge">parallel-canary</code>. The <code class="highlighter-rouge">-canary</code> strategies will invoke the first step as a “trial”, and then wait for the operator to manually confirm that the “trial” step was successful and invoke a <code class="highlighter-rouge">plan continue</code> call to continue the rollout. This may be useful in the case of deploying a configuration change to the cluster, where the first change is checked against a “canary” node before applying the rollout further.</p>
          </li>
          <li>
            <p><code class="highlighter-rouge">pod</code></p>

            <p>The name of the pod (listed above) against which this phase will be invoked.</p>
          </li>
          <li>
            <p><code class="highlighter-rouge">steps</code></p>

            <p>This section allows specifying non-default behavior for completing Steps. It may be used for e.g. defining custom init operations to be performed in the <code class="highlighter-rouge">deploy</code> plan, or for defining entirely custom plans for things like Backup and Restore. See the <a href="../developer-guide/#plans">SDK Developer Guide</a> for some examples and additional information on specifying custom steps.</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<!--  disable mustache templating in this file: retain templated examples as-is -->

</div>
</div>
</body>

</html>
